## 1241: 머리 톡톡

### 링크

- https://www.acmicpc.net/problem/1241

### 문제

엄지 생일 기념으로 학생들은 파티를 하고 있다. 엄지는 N(1≤N≤100,000)명의 학생에게 1부터 N번까지 차례대로 번호를 부여하였고 **그들을 순서대로 빙 둘러앉아 원을 만들게 하였다.** (즉 i번째 학생은 i-1과 i+1학생 사이에 앉아있다. 단, N번째 학생은 N-1번째 학생과 첫 번째 학생 사이에 앉아있다.)

N명의 학생은 둘러앉아 "머리톡톡" 게임을 하려한다. 게임 규칙은 다음과 같다. 각각의 학생은 자신의 머리 위에 1,000,000 이하의 자연수 중 하나를 쓴다. 그리고 1번부터 N번 학생까지 한 명씩 차례대로 일어나 원을 돌면서 **자신이 쓴 숫자가 다른 사람이 쓴 숫자의 배수이면 그 학생의 머리를 톡톡" 친다.**

문제는 각각의 학생이 일어나 자신의 자리로 돌아올 때까지 총 몇 명의 학생의 머리를 치는지 구하는 것이다.

#### 입력

첫째 줄에 학생의 수 N이 입력되고 다음 N개의 줄에는 1번부터 N번까지 각각의 학생이 자신의 머리에 쓴 숫자를 입력받는다.

#### 출력

총 N개의 줄로 i번째 줄에는 i번째 학생이 한 바퀴를 돌면서 머리를 친 학생의 수를 출력한다.

### 문제 분석

- 원형으로 모여서 게임을 수행한다.
- 한 학생을 중심으로 다른 학생의 번호를 비교해야 한다. 그러나 N이 최대 100,000이므로 O(N^2)의 시간 복잡도를 가져서는 안된다. (제한 시간 2초)

### 풀이

문제에서는 원형이라고 언급했기 때문에 순환 구조가 필요하다고 생각했다. 그래서 자신이 아닌 모든 학생의 숫자들을 인덱싱하여 `deque`에 append했습니다.  
그러나 **파이썬의 리스트 슬라이싱과 deque를 탐색하는 시간은 O(N)의 시간 복잡도를 가져** 시간 초과가 발생하게 되었습니다.(O(N^2))

리스트에 값을 추가하는 방식이 아닌 학생의 숫자의 빈도를 기반으로 숫자의 배수만큼 누적합을 구하는 방식으로 구현했습니다.

문제의 예시처럼 2, 1, 2, 3, 4 가 있다고 가정해보자.  
우선 학생들이 가질 수 있는 빈도 수를 구합니다.(freq)

|  1  |  2  |  3  |  4  |
| :-: | :-: | :-: | :-: |
|  1  |  2  |  1  |  1  |

그리고 **자신의 숫자의 빈도 수와 더불어 숫자의 배수만큼 빈도를 더하는 작업을 수행**합니다. 다만 **자기 자신이 포함되어 있으므로 1을 빼야 합니다.**

|    1    |         2         |         3         |              4              |      기타      |
| :-----: | :---------------: | :---------------: | :-------------------------: | :------------: |
| freq[1] | freq[1] + freq[2] | freq[1] + freq[3] | freq[1] + freq[2] + freq[4] |                |
|    1    |       1 + 2       |       1 + 1       |          1 + 2 + 1          |                |
|  1- 1   |       3 - 1       |       2 - 1       |            4 - 1            | 자기 자신 제외 |

### 코드

- [Python](./1241.py)
